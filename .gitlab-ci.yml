stages:
  - build
  - deploy

variables:
  SSH_USER: "ubuntu"
  SERVER_IP: "193.40.157.19"
  DEPLOY_PATH: "/srv/borsibaar"
  DOCKER_COMPOSE_FILE: "docker-compose.prod.yaml"

before_script:
  - 'which ssh-agent || apk add --no-cache openssh-client'
  - eval $(ssh-agent -s)
  - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan $SERVER_IP >> ~/.ssh/known_hosts

build-backend:
  stage: build
  image: maven:3.9-eclipse-temurin-21
  script:
    - cd backend
    - ./mvnw clean package -DskipTests
  artifacts:
    paths:
      - backend/target/*.jar
    expire_in: 1 hour
  only:
    - main
    - 22-create-a-pipeline-for-the-server

build-frontend:
  stage: build
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run build
  artifacts:
    paths:
      - frontend/.next/
      - frontend/public/
    expire_in: 1 hour
  only:
    - main
    - 22-create-a-pipeline-for-the-server

deploy-job:
  stage: deploy
  image: alpine:latest
  needs:
    - build-backend
    - build-frontend
  script:
    - echo "Starting deployment..."
    
    # Install required tools
    - apk add --no-cache tar

    # Copy the env file from GitLab CI/CD variable to current directory
    - cp $ENV_PRODUCTION_FILE .env.production
    
    # Create deployment package
    - tar czf deployment.tar.gz backend/target/*.jar frontend/ docker-compose.prod.yaml backend/Dockerfile .env.production
    
    # Copy to server
    - scp deployment.tar.gz $SSH_USER@$SERVER_IP:/tmp/
    
    # Deploy on server
    - |
        ssh $SSH_USER@$SERVER_IP << EOF
        set -e
        cd $DEPLOY_PATH
        
        # Extract deployment package
        tar xzf /tmp/deployment.tar.gz
        rm /tmp/deployment.tar.gz
        
        # Check if docker-compose.prod.yaml exists
        if [ ! -f $DOCKER_COMPOSE_FILE ]; then
          echo "ERROR: $DOCKER_COMPOSE_FILE not found!"
          exit 1
        fi

        # Copy environment file if exists
        if [ -f .env.production ]; then
          cp .env.production .env
        fi
        
        # Stop existing containers
        docker-compose -f $DOCKER_COMPOSE_FILE down
        
        # Rebuild and start containers
        docker-compose -f $DOCKER_COMPOSE_FILE build --no-cache
        docker-compose -f $DOCKER_COMPOSE_FILE up -d

        # Deploy frontend (standalone)
        sudo cp -r /tmp/frontend/.next $NGINX_ROOT/
        sudo cp -r /tmp/frontend/public $NGINX_ROOT/

        # Set correct permissions
        sudo chown -R www-data:www-data $NGINX_ROOT
        sudo chmod -R 755 $NGINX_ROOT

        # Reload nginx
        sudo nginx -t && sudo nginx -s reload
        
        # Clean up old images
        rm -rf /tmp/backend /tmp/frontend /tmp/.env.production
        docker image prune -f
        
        echo "Deployment complete!"
        docker-compose -f $DOCKER_COMPOSE_FILE ps
        EOF
  environment:
    name: production
    url: http://$SERVER_IP
  only:
    - main
    - 22-create-a-pipeline-for-the-server